import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:logging/logging.dart';

// Your project imports
import 'package:stuff/models/location_model.dart';
import 'package:stuff/core/image_identifier.dart';
import 'package:stuff/services/data_service_interface.dart';
import 'package:stuff/services/image_data_service_interface.dart';
import 'package:stuff/services/location_service_interface.dart';
import 'package:stuff/services/image_picker_service_interface.dart';
import 'package:stuff/services/temporary_file_service_interface.dart';
import 'package:stuff/services/exceptions/permission_exceptions.dart';
import 'package:stuff/services/exceptions/os_service_exceptions.dart';
import 'package:stuff/viewmodels/edit_location_view_model.dart';

// Import your mocks and test logger helper
import '../utils/test_logger_helper.dart'; // Assuming this is your logger helper path
import 'edit_location_view_model_test.mocks.dart'; // Generated by build_runner

// Helper to listen to ChangeNotifier notifications
class NotifyListener extends Mock {
  void call();
}

@GenerateMocks([
  IDataService,
  IImageDataService,
  ILocationService,
  IImagePickerService,
  ITemporaryFileService,
  File,
  Directory,
  FormState,
])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late MockIDataService mockDataService;
  late MockIImageDataService mockImageDataService;
  late MockILocationService mockLocationService;
  late MockIImagePickerService mockImagePickerService;
  late MockITemporaryFileService mockTempFileService;
  late MockDirectory mockTempDir;

  late TestLoggerManager loggerManager;
  late EditLocationViewModel viewModel;
  Location? initialLocation; // Used for testing edit mode

  // Helper to create the ViewModel with default mocks
  EditLocationViewModel createViewModel({
    Location? initialLoc,
    bool formShouldValidate = true,
    IImageDataService? imageDataService,
    String? nameControllerText,
  }) {
    final vm = EditLocationViewModel(
      dataService: mockDataService,
      imageDataService: imageDataService,
      locationService: mockLocationService,
      imagePickerService: mockImagePickerService,
      tempFileService: mockTempFileService,
      initialLocation: initialLoc,
      formValidator: () => formShouldValidate,
    );

    if (nameControllerText != null) {
      vm.nameController.text = nameControllerText;
    }
    return vm;
  }

  // Helper to simulate adding an image via ViewModel's API
  // Returns the File object that the ViewModel internally stores (the copied file)
  Future<MockFile> simulatePickAndCopyImage(
    EditLocationViewModel vm, {
    String pickedImageName = 'picked_temp.jpg',
    String copiedImageName = 'copied_temp.jpg',
    bool fromCamera = true,
  }) async {
    final mockPickedFile = MockFile();
    when(mockPickedFile.path).thenReturn(pickedImageName);

    final mockCopiedFile = MockFile();
    when(mockCopiedFile.path).thenReturn(
      '${mockTempDir.path}/$copiedImageName',
    ); // Ensure it's in temp dir

    if (fromCamera) {
      when(
        mockImagePickerService.pickImageFromCamera(),
      ).thenAnswer((_) async => mockPickedFile);
    } else {
      when(
        mockImagePickerService.pickImageFromGallery(),
      ).thenAnswer((_) async => mockPickedFile);
    }
    when(
      mockTempFileService.copyToTempDir(mockPickedFile, mockTempDir),
    ).thenAnswer((_) async => mockCopiedFile);

    if (fromCamera) {
      await vm.pickImageFromCamera();
    } else {
      await vm.pickImageFromGallery();
    }
    return mockCopiedFile;
  }

  setUp(() {
    mockDataService = MockIDataService();
    mockImageDataService = MockIImageDataService();
    mockLocationService = MockILocationService();
    mockImagePickerService = MockIImagePickerService();
    mockTempFileService = MockITemporaryFileService();
    mockTempDir = MockDirectory();

    // Default stub for temp directory creation
    when(
      mockTempFileService.createSessionTempDir(any),
    ).thenAnswer((_) async => mockTempDir);
    when(mockTempDir.path).thenReturn('/fake/temp/dir');
    when(
      mockTempDir.exists(),
    ).thenAnswer((_) async => true); // Assume exists after creation

    // Default stubs for services that might be called during initialization or early
    when(
      mockLocationService.isServiceEnabledAndPermitted(),
    ).thenAnswer((_) async => true);

    initialLocation = null; // Reset for each test, specific tests can set it

    loggerManager = TestLoggerManager();
    loggerManager.startCapture();
  });

  tearDown(() {
    loggerManager.stopCapture();
    viewModel.dispose(); // Ensure dispose is called
  });

  group('Initialization', () {
    test('initializes for a new location correctly', () async {
      viewModel = createViewModel();
      await Future.delayed(Duration.zero); // Allow async init tasks to complete

      expect(viewModel.isNewLocation, isTrue);
      expect(viewModel.nameController.text, isEmpty);
      expect(viewModel.descriptionController.text, isEmpty);
      expect(viewModel.addressController.text, isEmpty);
      expect(viewModel.currentImages, isEmpty);
      expect(viewModel.isGettingLocation, isFalse);
      expect(viewModel.deviceHasLocationService, isTrue); // Initial assumption
      expect(viewModel.locationPermissionDenied, isFalse);
      expect(viewModel.isSaving, isFalse);

      verify(
        mockTempFileService.createSessionTempDir('edit_location_session'),
      ).called(1);
      expect(
        loggerManager.findLogWithMessage(
          'Temporary image directory for this session: ${mockTempDir.path}',
          level: Level.INFO,
        ),
        isNotNull,
      );
    });

    test('initializes for an existing location correctly', () async {
      initialLocation = Location(
        id: 'loc1',
        name: 'Test Location',
        description: 'Test Desc',
        address: '123 Test St',
        imageGuids: ['guid1', 'guid2'],
      );
      viewModel = createViewModel(initialLoc: initialLocation);
      await Future.delayed(Duration.zero);

      expect(viewModel.isNewLocation, isFalse);
      expect(viewModel.nameController.text, 'Test Location');
      expect(viewModel.descriptionController.text, 'Test Desc');
      expect(viewModel.addressController.text, '123 Test St');
      expect(viewModel.currentImages.length, 2);
      expect(viewModel.currentImages[0], isA<GuidIdentifier>());
      expect((viewModel.currentImages[0] as GuidIdentifier).guid, 'guid1');
      expect(viewModel.isSaving, isFalse);
      verify(
        mockTempFileService.createSessionTempDir('edit_location_session'),
      ).called(1);
    });

    test('handles failure in _initializeTempDirectory gracefully', () async {
      when(
        mockTempFileService.createSessionTempDir(any),
      ).thenThrow(Exception("Failed to create dir"));

      viewModel = createViewModel();
      await Future.delayed(Duration.zero); // Allow async init

      expect(
        loggerManager.findLogWithMessage(
          'Failed to initialize temporary image directory',
          level: Level.SEVERE,
        ),
        isNotNull,
      );
      // ViewModel should still be usable, _tempDir will be null
    });
  });

  group('Location Service Status', () {
    setUp(() {
      viewModel = createViewModel(); // Initialize fresh VM for this group
    });

    test(
      'refreshLocationServiceStatus updates status and notifies listeners if changed',
      () async {
        final listener = NotifyListener();
        viewModel.addListener(listener.call);

        when(
          mockLocationService.isServiceEnabledAndPermitted(),
        ).thenAnswer((_) async => false);
        await viewModel.refreshLocationServiceStatus();

        expect(viewModel.deviceHasLocationService, isFalse);
        expect(viewModel.locationPermissionDenied, isTrue);
        verify(listener()).called(1); // Notified

        when(
          mockLocationService.isServiceEnabledAndPermitted(),
        ).thenAnswer((_) async => true);
        await viewModel.refreshLocationServiceStatus();
        expect(viewModel.deviceHasLocationService, isTrue);
        expect(viewModel.locationPermissionDenied, isFalse);
        verify(listener()).called(1); // Notified again

        viewModel.removeListener(listener.call);
      },
    );

    test(
      'checkLocationServiceStatus updates status but only notifies if changed',
      () async {
        final listener = NotifyListener();
        viewModel.addListener(listener.call);

        when(
          mockLocationService.isServiceEnabledAndPermitted(),
        ).thenAnswer((_) async => true); // no change
        await viewModel.checkLocationServiceStatus();
        expect(viewModel.deviceHasLocationService, isTrue);
        verifyNever(listener()); // Not notified if status is same

        when(
          mockLocationService.isServiceEnabledAndPermitted(),
        ).thenAnswer((_) async => false); // change
        await viewModel.checkLocationServiceStatus();
        expect(viewModel.deviceHasLocationService, isFalse);
        verify(listener()).called(1); // Notified

        viewModel.removeListener(listener.call);
      },
    );
  });

  group('getCurrentAddress', () {
    setUp(() {
      viewModel = createViewModel();
      // Ensure temp dir is initialized for other tests that might run after this group
      // This is a bit of a workaround for group-level VM re-initialization.
      // Alternatively, ensure _initializeTempDirectory is robust to null _tempDir.
      when(
        mockTempFileService.createSessionTempDir(any),
      ).thenAnswer((_) async => mockTempDir);
    });

    test('successfully gets and sets address', () async {
      final listener = NotifyListener();
      viewModel.addListener(listener.call);
      when(
        mockLocationService.getCurrentAddress(),
      ).thenAnswer((_) async => 'Test Address');

      await viewModel.getCurrentAddress();

      expect(viewModel.addressController.text, 'Test Address');
      expect(viewModel.isGettingLocation, isFalse);
      expect(viewModel.deviceHasLocationService, isTrue);
      expect(viewModel.locationPermissionDenied, isFalse);
      verify(listener()).called(greaterThan(0)); // notified for start and end
      viewModel.removeListener(listener.call);
    });

    test('handles LocationPermissionDeniedException', () async {
      final listener = NotifyListener();
      viewModel.addListener(listener.call);
      when(
        mockLocationService.getCurrentAddress(),
      ).thenThrow(LocationPermissionDeniedException('denied'));

      await viewModel.getCurrentAddress();

      expect(viewModel.isGettingLocation, isFalse);
      expect(viewModel.deviceHasLocationService, isFalse);
      expect(viewModel.locationPermissionDenied, isTrue);
      expect(
        loggerManager.findLogWithMessage(
          'Location permission denied',
          level: Level.WARNING,
        ),
        isNotNull,
      );
      verify(listener()).called(greaterThan(0));
      viewModel.removeListener(listener.call);
    });

    test('handles PermissionDeniedPermanentlyException', () async {
      when(
        mockLocationService.getCurrentAddress(),
      ).thenThrow(PermissionDeniedPermanentlyException('perm denied'));
      await viewModel.getCurrentAddress();
      expect(viewModel.deviceHasLocationService, isFalse);
      expect(viewModel.locationPermissionDenied, isTrue);
      expect(
        loggerManager.findLogWithMessage(
          'Location permission permanently denied',
          level: Level.WARNING,
        ),
        isNotNull,
      );
    });

    test('handles OSServiceDisabledException', () async {
      when(mockLocationService.getCurrentAddress()).thenThrow(
        OSServiceDisabledException(
          serviceName: 'LocationService',
          message: 'disabled',
        ),
      );
      await viewModel.getCurrentAddress();
      expect(viewModel.deviceHasLocationService, isFalse);
      expect(viewModel.locationPermissionDenied, isTrue);
      expect(
        loggerManager.findLogWithMessage(
          'Location service disabled',
          level: Level.WARNING,
        ),
        isNotNull,
      );
    });

    test('handles generic exception', () async {
      when(
        mockLocationService.getCurrentAddress(),
      ).thenThrow(Exception('generic error'));
      await viewModel.getCurrentAddress();
      expect(viewModel.deviceHasLocationService, isFalse);
      expect(viewModel.locationPermissionDenied, isTrue);
      expect(
        loggerManager.findLogWithMessage(
          'Error getting current address',
          level: Level.SEVERE,
        ),
        isNotNull,
      );
    });

    test('does nothing if already getting location', () async {
      final addressCompleter = Completer<String>();
      when(
        mockLocationService.getCurrentAddress(),
      ).thenAnswer((_) => addressCompleter.future);

      final call1Future = viewModel.getCurrentAddress(); // Don't await yet

      // At this point, _isGettingLocation should be true.
      // Call it again. This call should hit the guard.
      final call2Future = viewModel.getCurrentAddress(); // Don't await yet

      // Now complete the first operation
      addressCompleter.complete('Test Address');

      // Await both futures to ensure all async operations related to them are done
      await call1Future;
      await call2Future; // This future should complete quickly as it should have done nothing

      verify(
        mockLocationService.getCurrentAddress(),
      ).called(1); // Should only be called once
    });
  });

  group('Image Picking', () {
    late MockFile mockPickedFile;
    late MockFile mockCopiedFile;

    setUp(() async {
      // Initialize view model here to ensure _tempDir is set up by _initializeTempDirectory
      // This is crucial because _pickImage checks for _tempDir
      viewModel = createViewModel();
      await Future.delayed(
        Duration.zero,
      ); // allow _initializeTempDirectory to run

      mockPickedFile = MockFile();
      mockCopiedFile = MockFile();
      when(mockPickedFile.path).thenReturn('/fake/picked/image.jpg');
      when(mockCopiedFile.path).thenReturn('/fake/temp/dir/copied_image.jpg');

      when(
        mockTempFileService.copyToTempDir(mockPickedFile, mockTempDir),
      ).thenAnswer((_) async => mockCopiedFile);
    });

    test(
      'pickImageFromCamera successfully picks, copies, and adds image',
      () async {
        final listener = NotifyListener();
        viewModel.addListener(listener.call);
        when(
          mockImagePickerService.pickImageFromCamera(),
        ).thenAnswer((_) async => mockPickedFile);

        await viewModel.pickImageFromCamera();

        expect(viewModel.currentImages.length, 1);
        expect(viewModel.currentImages[0], isA<TempFileIdentifier>());
        expect(
          (viewModel.currentImages[0] as TempFileIdentifier).file,
          mockCopiedFile,
        );
        verify(listener()).called(1);
        expect(
          loggerManager.findLogWithMessage(
            'New image picked and copied to temporary location: ${mockCopiedFile.path}',
            level: Level.INFO,
          ),
          isNotNull,
        );
        viewModel.removeListener(listener.call);
      },
    );

    test(
      'pickImageFromGallery successfully picks, copies, and adds image',
      () async {
        when(
          mockImagePickerService.pickImageFromGallery(),
        ).thenAnswer((_) async => mockPickedFile);
        await viewModel.pickImageFromGallery();
        expect(viewModel.currentImages.length, 1);
        // ... similar asserts as camera
      },
    );

    test('_pickImage does nothing if picked file is null', () async {
      final listener = NotifyListener();
      viewModel.addListener(listener.call);
      when(
        mockImagePickerService.pickImageFromCamera(),
      ).thenAnswer((_) async => null);
      await viewModel.pickImageFromCamera();
      expect(viewModel.currentImages.isEmpty, isTrue);
      verifyNever(listener()); // Not notified if no image is added
      viewModel.removeListener(listener.call);
    });

    test('_pickImage logs warning if tempDir is null', () async {
      // Create a new VM where _initializeTempDirectory fails to set _tempDir
      when(
        mockTempFileService.createSessionTempDir(any),
      ).thenThrow(Exception('Simulated failure to create temp directory'));
      final freshViewModel = createViewModel();
      await Future.delayed(Duration.zero); // allow async init

      await freshViewModel.pickImageFromCamera(); // Call pickImage on this VM
      expect(
        loggerManager.findLogWithMessage(
          'Temporary directory not initialized. Cannot pick image.',
          level: Level.WARNING,
        ),
        isNotNull,
      );
      expect(
        freshViewModel.currentImages.isEmpty,
        isTrue,
      ); // No image should be added
      freshViewModel.dispose();
    });

    test('_pickImage handles exception during picking/copying', () async {
      when(
        mockImagePickerService.pickImageFromCamera(),
      ).thenAnswer((_) async => mockPickedFile);
      when(
        mockTempFileService.copyToTempDir(mockPickedFile, mockTempDir),
      ).thenThrow(Exception('copy failed'));

      await viewModel.pickImageFromCamera();

      expect(viewModel.currentImages.isEmpty, isTrue);
      expect(
        loggerManager.findLogWithMessage(
          'Error picking/copying image to temp',
          level: Level.SEVERE,
        ),
        isNotNull,
      );
    });
  });

  group('removeImage', () {
    late MockFile mockTempFile1;
    late EditLocationViewModel
    vm; // Use a local VM for this group for cleaner state

    setUp(() async {
      mockTempFile1 = MockFile();
      when(mockTempFile1.path).thenReturn('/fake/temp/dir/img1.jpg');

      vm = createViewModel();
      await Future.delayed(Duration.zero); // allow async init

      // Helper to add a temp image for testing removal
      final pickedFile = MockFile();
      when(pickedFile.path).thenReturn('dummy_picked.jpg');
      when(
        mockImagePickerService.pickImageFromCamera(),
      ).thenAnswer((_) async => pickedFile);
      when(
        mockTempFileService.copyToTempDir(pickedFile, mockTempDir),
      ).thenAnswer((_) async => mockTempFile1);
      await vm
          .pickImageFromCamera(); // Adds mockTempFile1 as TempFileIdentifier
      clearInteractions(
        mockImagePickerService,
      ); // Clear interactions after setup
      clearInteractions(mockTempFileService); // Clear interactions after setup
      when(
            mockTempFileService.createSessionTempDir(any),
          ) // Re-stub for subsequent calls if needed by other setup
          .thenAnswer((_) async => mockTempDir);
    });

    tearDown(() {
      vm.dispose();
    });

    test('removes TempFileIdentifier and deletes file', () async {
      expect(vm.currentImages.length, 1);
      final listener = NotifyListener();
      vm.addListener(listener.call);

      await vm.removeImage(0);

      expect(vm.currentImages.isEmpty, isTrue);
      verify(mockTempFileService.deleteFile(mockTempFile1)).called(1);
      verify(listener()).called(1);
      expect(
        loggerManager.findLogWithMessage(
          'Temporary image file deleted: ${mockTempFile1.path}',
          level: Level.INFO,
        ),
        isNotNull,
      );
      vm.removeListener(listener.call);
    });

    test('removes GuidIdentifier and logs (no file deletion yet)', () async {
      // Setup: Add a GuidIdentifier
      vm = createViewModel(
        initialLoc: Location(
          id: 'loc1',
          name: 'Test',
          imageGuids: ['guid-to-remove'],
        ),
      );
      await Future.delayed(Duration.zero);
      expect(vm.currentImages.length, 1);
      expect(vm.currentImages[0], isA<GuidIdentifier>());

      final listener = NotifyListener();
      vm.addListener(listener.call);
      await vm.removeImage(0);

      expect(vm.currentImages.isEmpty, isTrue);
      verifyNever(mockTempFileService.deleteFile(any)); // No temp file deletion
      verify(listener()).called(1);
      expect(
        loggerManager.findLogWithMessage(
          "Image with GUID guid-to-remove marked for removal",
          level: Level.INFO,
        ),
        isNotNull,
      );
      vm.removeListener(listener.call);
    });

    test(
      'handles error during temp file deletion when removing TempFileIdentifier',
      () async {
        when(
          mockTempFileService.deleteFile(mockTempFile1),
        ).thenThrow(Exception('delete failed'));
        await vm.removeImage(
          0,
        ); // Assumes mockTempFile1 is still the first image

        expect(
          vm.currentImages.isEmpty,
          isTrue,
        ); // Image is still removed from list
        expect(
          loggerManager.findLogWithMessage(
            'Failed to delete temporary image file',
            level: Level.WARNING,
          ),
          isNotNull,
        );
      },
    );

    test('does nothing for invalid index', () async {
      final listener = NotifyListener();
      vm.addListener(listener.call);
      await vm.removeImage(-1);
      await vm.removeImage(vm.currentImages.length + 1); // out of bounds

      expect(vm.currentImages.length, 1); // No change
      verifyNever(listener());
      vm.removeListener(listener.call);
    });
  });

  group('saveLocation', () {
    setUp(() async {
      when(mockDataService.addLocation(any)).thenAnswer((_) async {});
      when(mockDataService.updateLocation(any)).thenAnswer((_) async {});
      when(
        mockTempFileService.deleteDirectory(mockTempDir),
      ).thenAnswer((_) async {});

      when(mockImageDataService.saveUserImage(any)).thenAnswer((
        invocation,
      ) async {
        final file = invocation.positionalArguments.first as File;
        return 'guid_for_${file.path.split('/').last}'; // Generic GUID
      });
      when(mockImageDataService.deleteUserImage(any)).thenAnswer((_) async {});
    });

    tearDown(() {});

    test(
      'returns false if already saving and does not call services multiple times',
      () async {
        viewModel = createViewModel(
          formShouldValidate: true,
        ); // Ensures validation passes
        viewModel.nameController.text =
            "Test Location"; // Minimal data for location object

        final saveCompleter = Completer<void>();
        when(mockDataService.addLocation(any)).thenAnswer((_) {
          return saveCompleter.future;
        });

        final firstSaveFuture = viewModel.saveLocation();

        // Give a very brief moment for the first call to execute up to the await on the completer
        await Future.delayed(Duration.zero);
        expect(
          viewModel.isSaving,
          isTrue,
          reason: "_isSaving should be true after the first call starts",
        );

        // Call saveLocation again while the first one is still "in progress"
        final result = await viewModel.saveLocation();
        expect(
          result,
          isFalse,
          reason:
              "Second call to saveLocation should return false when already saving",
        );

        // Complete the first save operation (allowing it to finish)
        saveCompleter
            .complete(); // Allow the first mocked addLocation to complete
        await firstSaveFuture; // Now await the first future to ensure it finishes cleanly

        verify(mockDataService.addLocation(any)).called(1);

        verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);
        expect(
          viewModel.isSaving,
          isFalse,
          reason: "_isSaving should be reset after all operations",
        );
      },
    );

    test('successfully saves a new location with no images', () async {
      viewModel = createViewModel();
      viewModel.nameController.text = "New Location";

      final listener = NotifyListener();
      viewModel.addListener(listener.call);

      final result = await viewModel.saveLocation();

      expect(result, isTrue);
      expect(viewModel.isSaving, isFalse); // Reset after save
      verify(mockDataService.addLocation(any)).called(1);
      verifyNever(mockImageDataService.saveUserImage(any));
      verifyNever(mockImageDataService.deleteUserImage(any));
      verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);
      verify(listener()).called(greaterThan(0)); // for isSaving changes
      expect(
        loggerManager.findLogWithMessage(
          'New location added successfully',
          level: Level.INFO,
        ),
        isNotNull,
      );
      viewModel.removeListener(listener.call);
    });

    test(
      'successfully saves a new location with new images (ImageDataService available)',
      () async {
        // ViewModel setup
        viewModel = createViewModel(
          imageDataService: mockImageDataService,
          nameControllerText: "New Location With Image",
          formShouldValidate: true,
        );

        await Future.delayed(Duration.zero);

        // Simulate picking and adding an image via ViewModel's API
        final mockCopiedFileForSave = await simulatePickAndCopyImage(
          viewModel,
          copiedImageName: 'new_image.jpg',
        );

        // Stub image saving
        when(
          mockImageDataService.saveUserImage(
            mockCopiedFileForSave,
          ), // Use the copied file
        ).thenAnswer((_) async => 'saved_guid_1');

        // Stub data service for adding location
        when(mockDataService.addLocation(any)).thenAnswer((_) async {});

        final result = await viewModel.saveLocation();

        expect(result, isTrue);
        verify(
          mockDataService.addLocation(
            argThat(
              predicate<Location>((loc) {
                return loc.name ==
                        "New Location With Image" && // Check name too
                    loc.imageGuids != null &&
                    loc.imageGuids!.contains('saved_guid_1');
              }),
            ),
          ),
        ).called(1);
        verify(
          mockImageDataService.saveUserImage(mockCopiedFileForSave),
        ).called(1);
        expect(
          loggerManager.findLogWithMessage(
            "Saved temp image ${mockCopiedFileForSave.path} as GUID: saved_guid_1",
            level: Level.INFO,
          ),
          isNotNull,
        );
      },
    );

    test(
      'successfully updates an existing location, removing an old image, adding new',
      () async {
        initialLocation = Location(
          id: 'loc1',
          name: 'Old Name',
          imageGuids: ['old_guid_1', 'guid_to_keep'],
        );
        viewModel = createViewModel(
          imageDataService: mockImageDataService,
          initialLoc: initialLocation,
          formShouldValidate: true,
          nameControllerText: "Updated Name",
        );
        await Future.delayed(
          Duration.zero,
        ); // init and allow _initializeTempDirectory

        // 1. Remove 'old_guid_1' using ViewModel's API
        // Find the index of the image to remove.
        // The ViewModel's currentImages list will initially contain ImageIdentifier objects.
        int indexOfOldGuid = viewModel.currentImages.indexWhere(
          (img) => img is GuidIdentifier && img.guid == 'old_guid_1',
        );
        expect(
          indexOfOldGuid,
          isNot(-1),
          reason: "Test setup: 'old_guid_1' not found in initial images",
        );
        await viewModel.removeImage(
          indexOfOldGuid,
        ); // This should mark 'old_guid_1' for deletion

        // 2. Add a new image using ViewModel's API
        final mockCopiedNewImage = await simulatePickAndCopyImage(
          viewModel,
          copiedImageName: 'new_temp.jpg', // Path for the new temp image
        );

        // 3. Stub service calls
        when(
          mockImageDataService.saveUserImage(mockCopiedNewImage),
        ).thenAnswer((_) async => 'new_saved_guid');
        when(
          mockImageDataService.deleteUserImage('old_guid_1'),
        ).thenAnswer((_) async {});
        when(mockDataService.updateLocation(any)).thenAnswer((_) async {});

        final result = await viewModel.saveLocation();
        expect(result, isTrue);

        verify(
          mockDataService.updateLocation(
            argThat(
              predicate<Location>((loc) {
                return loc.id == 'loc1' &&
                    loc.name == "Updated Name" &&
                    loc.imageGuids!.contains('guid_to_keep') &&
                    loc.imageGuids!.contains('new_saved_guid') &&
                    !loc.imageGuids!.contains('old_guid_1');
              }),
            ),
          ),
        ).called(1);
        verify(
          mockImageDataService.saveUserImage(mockCopiedNewImage),
        ).called(1);
        verify(mockImageDataService.deleteUserImage('old_guid_1')).called(1);
        expect(
          loggerManager.findLogWithMessage(
            "Permanently deleting image GUID: old_guid_1",
            level: Level.INFO,
          ),
          isNotNull,
        );
        expect(
          loggerManager.findLogWithMessage(
            "Saved temp image ${mockCopiedNewImage.path} as GUID: new_saved_guid",
            level: Level.INFO,
          ),
          isNotNull,
        );
      },
    );

    test(
      'saveLocation fails if ImageDataService is null and new images are present',
      () async {
        viewModel = createViewModel(
          imageDataService: null,
          formShouldValidate: true,
          nameControllerText: "Location Name",
        );
        await Future.delayed(Duration.zero);

        // Add a temp image using ViewModel's API
        final mockCopiedTempImage = await simulatePickAndCopyImage(
          viewModel,
          copiedImageName: 'new_image.jpg',
        );

        final result = await viewModel.saveLocation();

        expect(result, isFalse);
        verifyNever(mockDataService.addLocation(any)); // Or updateLocation
        expect(
          loggerManager.findLogWithMessage(
            'Cannot save new images: IImageDataService is not available.',
            level: Level.SEVERE,
          ),
          isNotNull,
        );

        verify(mockTempFileService.deleteFile(mockCopiedTempImage)).called(1);

        expect(
          loggerManager.findLogWithMessage(
            'Cleaned up unsaved temp image: ${mockCopiedTempImage.path}',
            level: Level.INFO,
          ),
          isNotNull,
        );
      },
    );

    test(
      'saveLocation proceeds if ImageDataService is null and only existing images are present',
      () async {
        initialLocation = Location(
          id: 'loc1',
          name: 'Old Name',
          imageGuids: ['guid_to_keep'],
        );
        viewModel = createViewModel(
          imageDataService: null,
          initialLoc: initialLocation,
          formShouldValidate: true,
        );
        await Future.delayed(Duration.zero); // init

        viewModel.nameController.text = "Updated Name";

        // No new images are added. currentImages should only contain GuidIdentifier('guid_to_keep')

        when(
          mockDataService.updateLocation(any),
        ).thenAnswer((_) async {}); // Stub for update

        final result = await viewModel.saveLocation();

        expect(result, isTrue);
        verify(
          mockDataService.updateLocation(
            argThat(
              predicate<Location>((loc) {
                return loc.id == 'loc1' &&
                    loc.name == "Updated Name" &&
                    loc.imageGuids != null &&
                    loc.imageGuids!.length ==
                        1 && // Ensure no other images crept in
                    loc.imageGuids!.contains('guid_to_keep');
              }),
            ),
          ),
        ).called(1);
        verifyNever(mockImageDataService.saveUserImage(any));
        verifyNever(mockImageDataService.deleteUserImage(any));
        expect(
          loggerManager.findLogWithMessage(
            'IImageDataService is null. Proceeding without image saving/deletion capabilities.',
            level: Level.WARNING,
          ),
          isNotNull,
        );
      },
    );

    test(
      'handles error during _processImagesForSave (e.g., image save fails)',
      () async {
        viewModel = createViewModel(
          imageDataService: mockImageDataService,
          formShouldValidate: true,
        );
        await Future.delayed(Duration.zero); // init

        // Add a temp image using ViewModel's API
        final mockCopiedTempImage = await simulatePickAndCopyImage(
          viewModel,
          copiedImageName: 'new_image.jpg',
        );

        // Stub image saving to throw an error
        when(
          mockImageDataService.saveUserImage(mockCopiedTempImage),
        ).thenThrow(Exception('Failed to save image file'));

        // Ensure addLocation is stubbed, though it shouldn't be called
        when(mockDataService.addLocation(any)).thenAnswer((_) async {});

        final result = await viewModel.saveLocation();

        expect(result, isFalse);
        expect(viewModel.isSaving, isFalse); // Should be reset
        verifyNever(mockDataService.addLocation(any)); // Or updateLocation

        // Verify temp directory cleanup (assuming it runs even on image processing error)
        verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);

        expect(
          loggerManager.findLogWithMessage(
            'Error saving location or processing images',
            level: Level.SEVERE,
          ),
          isNotNull,
        );
        expect(
          loggerManager.findLogWithMessage(
            'Failed to save image ${mockCopiedTempImage.path}',
            level: Level.SEVERE,
          ),
          isNotNull,
        );
        expect(
          loggerManager.findLogWithMessage(
            'Exception: Failed to save image file',
            level: Level.SEVERE,
          ),
          isNotNull,
        );
      },
    );

    test(
      'handles error during _saveLocationData (e.g., DB operation fails for new location)',
      () async {
        viewModel = createViewModel(formShouldValidate: true);
        await Future.delayed(Duration.zero); // init

        // No new images needed for this specific DB error test, unless your VM requires them.
        // If images ARE involved and _processImagesForSave runs first, ensure it's stubbed successfully.
        // For simplicity, let's assume no new images for this DB error test.

        // Stub DB operation (addLocation for a new location) to throw an error
        when(mockDataService.addLocation(any)).thenThrow(Exception('DB error'));

        final result = await viewModel.saveLocation();

        expect(result, isFalse);
        expect(viewModel.isSaving, isFalse); // Should be reset

        // Temp directory cleanup should still run
        verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);

        expect(
          loggerManager.findLogWithMessage(
            'Error saving location or processing images',
            level: Level.SEVERE,
          ),
          isNotNull,
        );
        expect(
          loggerManager.findLogWithMessage('DB error', level: Level.SEVERE),
          isNotNull,
        );
      },
    );

    test(
      'handles error during _saveLocationData (e.g., DB operation fails for existing location)',
      () async {
        initialLocation = Location(id: 'loc1', name: 'Old Name');
        viewModel = createViewModel(
          initialLoc: initialLocation,
          formShouldValidate: true,
        );
        await Future.delayed(Duration.zero); // init

        // Stub DB operation (updateLocation for an existing location) to throw an error
        when(
          mockDataService.updateLocation(any),
        ).thenThrow(Exception('DB update error'));

        final result = await viewModel.saveLocation();

        expect(result, isFalse);
        expect(viewModel.isSaving, isFalse);

        verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);

        expect(
          loggerManager.findLogWithMessage(
            'Error saving location or processing images',
            level: Level.SEVERE,
          ),
          isNotNull,
        );
        expect(
          loggerManager.findLogWithMessage(
            'DB update error',
            level: Level.SEVERE,
          ),
          isNotNull,
        );
      },
    );
  });

  group('Cleanup and Dispose', () {
    test('handleDiscardOrPop calls _cleanupTempDir', () async {
      viewModel = createViewModel();
      await Future.delayed(Duration.zero); // for _initializeTempDirectory

      await viewModel.handleDiscardOrPop();
      verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);
      expect(
        loggerManager.findLogWithMessage(
          'Cleaned up temporary image directory',
          level: Level.INFO,
        ),
        isNotNull,
      );
    });

    test('_cleanupTempDir deletes directory if it exists', () async {
      viewModel = createViewModel(); // This will call _initializeTempDirectory
      await Future.delayed(Duration.zero);
      // _cleanupTempDir is called by saveLocation or handleDiscardOrPop or dispose

      // Simulate a scenario where cleanup is called explicitly or via another method
      // For this test, we can call it directly after ensuring _tempDir is set.
      // Or, better, test it via a public method that calls it like handleDiscardOrPop.
      await viewModel.handleDiscardOrPop(); // This calls _cleanupTempDir

      verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);
    });

    test('_cleanupTempDir does nothing if _tempDir is null', () async {
      when(
        mockTempFileService.createSessionTempDir(any),
      ).thenThrow(Exception('Simulated failure to create temp directory'));
      viewModel = createViewModel();
      await Future.delayed(Duration.zero);

      await viewModel.handleDiscardOrPop();
      verifyNever(mockTempFileService.deleteDirectory(any));
    });

    test('_cleanupTempDir handles error during directory deletion', () async {
      viewModel = createViewModel();
      await Future.delayed(Duration.zero);
      when(
        mockTempFileService.deleteDirectory(mockTempDir),
      ).thenThrow(Exception('delete dir failed'));

      await viewModel.handleDiscardOrPop();
      expect(
        loggerManager.findLogWithMessage(
          'Failed to clean up temporary image directory',
          level: Level.WARNING,
        ),
        isNotNull,
      );
    });

    test(
      'dispose calls controller disposers and _cleanupTempDir if tempDir was not cleaned up',
      () async {
        viewModel = createViewModel();
        await Future.delayed(Duration.zero);

        viewModel.dispose();

        await pumpEventQueue();

        // Verify _cleanupTempDir's core action was attempted because _tempDir was not null
        verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);
        expect(
          loggerManager.findLogWithMessage(
            "ViewModel disposed, but temp directory was not cleaned up",
            level: Level.WARNING,
          ),
          isNotNull,
        );
      },
    );

    test(
      'dispose does not try to cleanup tempDir if already null (cleaned up by save/discard)',
      () async {
        viewModel = createViewModel();
        await Future.delayed(Duration.zero); // _tempDir is set

        // Simulate cleanup before dispose (e.g., after a successful save)
        await viewModel
            .handleDiscardOrPop(); // This will clean up _tempDir and set it to null
        verify(
          mockTempFileService.deleteDirectory(mockTempDir),
        ).called(1); // Verify it was called once

        // Clear interactions to check dispose doesn't call it again
        // Re-stub createSessionTempDir if it's unexpectedly called again by other parts of the test setup.
        // This is generally not needed if tearDown handles VM recreation properly.
        clearInteractions(mockTempFileService);
        when(
          mockTempFileService.createSessionTempDir(any),
        ).thenAnswer((_) async => mockTempDir);

        viewModel.dispose();

        verifyNever(
          mockTempFileService.deleteDirectory(any),
        ); // Should not be called again by dispose
        expect(
          loggerManager.findLogWithMessage(
            "ViewModel disposed, but temp directory was not cleaned up",
            level: Level.WARNING,
          ),
          isNull,
        ); // Log shouldn't appear
      },
    );

    test(
      'dispose sets _isDisposed and can be called multiple times safely',
      () async {
        viewModel = createViewModel();
        await Future.delayed(Duration.zero);

        expect(viewModel.isDisposed, isFalse);

        viewModel.dispose();
        await pumpEventQueue();
        expect(viewModel.isDisposed, isTrue);

        // Call dispose again
        viewModel.dispose();
        await pumpEventQueue();

        verify(mockTempFileService.deleteDirectory(mockTempDir)).called(1);
      },
    );
  });
}
